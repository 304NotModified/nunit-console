# SyntaxElements.txt
#
# ***********************************************************************
#  Copyright (c) 2009 Charlie Poole
#
#  Permission is hereby granted, free of charge, to any person obtaining
#  a copy of this software and associated documentation files (the
#  "Software"), to deal in the Software without restriction, including
#  without limitation the rights to use, copy, modify, merge, publish,
#  distribute, sublicense, and/or sell copies of the Software, and to
#  permit persons to whom the Software is furnished to do so, subject to
#  the following conditions:
#  
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
# 
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
#  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
#  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
#  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
# ***********************************************************************
#
# This file is used to control generation of certain source files
# in the NUnit framework, so that all overloads are defined
# consistently.
#
# The file is organized in stanzas, seperated by a line containing
# only a percent sign (%) in the first column. Each stanza contains
# information used to generate code for one or more classes.
#
# Within a stanza, individual lines are recognized by a prefix
# and lines not starting with a recognized prefix will cause an 
# exception. With the exception of # and /// all prefixes are
# terminated by a colon.
#
# NOTE: Lines beginning with whitespace are treated as a
# continuation of the preceding line.
# 
# Prefix '#' introduces a comment. Use an otherwise blank line 
#   starting with '#' for spacing, if desired.
#
# Prefix '///' introduces a comment to be included in the
#   generated source code. Each stanza contains a single block
#   of comments, conventionally placed at the beginning of
#   the stanza. All methods generated from a stanza use
#   the same comment. 
#
# Prefix 'Cond:' may appear once in each stanza and
#   gives an expression that will be used with #if to include
#   or exclude code from the entire stanza from the build.
#   For example: 'Cond: !NETCF'
#
# Prefix 'Type:' may appear once in each stanza and indicates
#   the return type of the methods defined in the stanza. If
#   it is not specified, all methods default to 'void'.
#
# Prefix 'Gen:' introduces a method or property definition.
#   The format of the line is as follows:
#     'Gen:' [attributes]...signature=>definition
#   where 
#     [attributes] represents any attributes to be placed on the
#        method. It is optional and may be repeated.
#      signature is the method signature, including the class
#        name and arguments.
#      definition is the code for the method
#
#   The code generator distinguishes methods from properties
#   and generates the necessary get {...} sequence in the 
#   latter case. Note that only getters are generated. If
#   the method signature uses generics, the entire definition
#   is enclosed in an #if CLR_2_0 || CLR_4_0 ... #endif sequence.
#
#   If the class name in a method signature is 'Assert' the
#   code generator creates multiple overloads of the method,
#   allowing for provision of an optional message and args.
#
# Prefix 'Gen3' causes the code generator to create code
#   in three classes: a static helper class specified in
#   the signature, the ConstraintFactory class and the
#   ConstraintExpression class. These three classes are
#   used by the NUnit fluent syntax. The code after the
#   arrow (=>) is used in all three definitions.
#
# You may browse the remainder of this file for examples
# of use of each prefix.
#
#
#
# Prefix Operators
#
/// <summary>
/// Returns a ConstraintExpression that negates any
/// following constraint.
/// </summary>
Type: ConstraintExpression
Gen: Is.Not=>new ConstraintExpression().Not
Gen: Has.No=>new ConstraintExpression().Not
Gen: ConstraintFactory.Not=>Is.Not
Gen: ConstraintFactory.No=>Has.No
Gen: ConstraintExpression.Not=>this.Append(new NotOperator())
Gen: ConstraintExpression.No=>this.Append(new NotOperator())
%
/// <summary>
/// Returns a ConstraintExpression, which will apply
/// the following constraint to all members of a collection,
/// succeeding if all of them succeed.
/// </summary>
Type: ConstraintExpression
Gen: Is.All=>new ConstraintExpression().All
Gen: Has.All=>new ConstraintExpression().All
Gen: ConstraintFactory.All=>Is.All
Gen: ConstraintExpression.All=>this.Append(new AllOperator())
%
/// <summary>
/// Returns a ConstraintExpression, which will apply
/// the following constraint to all members of a collection,
/// succeeding if at least one of them succeeds.
/// </summary>
Type: ConstraintExpression
Gen: Has.Some=>new ConstraintExpression().Some
Gen: ConstraintFactory.Some=>Has.Some
Gen: ConstraintExpression.Some=>this.Append(new SomeOperator())
%
/// <summary>
/// Returns a ConstraintExpression, which will apply
/// the following constraint to all members of a collection,
/// succeeding if all of them fail.
/// </summary>
Type: ConstraintExpression
Gen: Has.None=>new ConstraintExpression().None
Gen: ConstraintFactory.None=>Has.None
Gen: ConstraintExpression.None=>this.Append(new NoneOperator())
%
/// <summary>
/// Returns a new PropertyConstraintExpression, which will either
/// test for the existence of the named property on the object
/// being tested or apply any following constraint to that property.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Property(string name)=>new ConstraintExpression().Property(name)
Gen: ConstraintFactory.Property(string name)=>Has.Property(name)
Gen: ConstraintExpression.Property(string name)=>this.Append(new PropOperator(name))
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the Length property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Length=>Property("Length")
Gen: ConstraintFactory.Length=>Has.Length
Gen: ConstraintExpression.Length=>Property("Length")
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the Count property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Count=>Property("Count")
Gen: ConstraintFactory.Count=>Has.Count
Gen: ConstraintExpression.Count=>Property("Count")
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the Message property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Message=>Property("Message")
Gen: ConstraintFactory.Message=>Has.Message
Gen: ConstraintExpression.Message=>Property("Message")
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the InnerException property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.InnerException=>Property("InnerException")
Gen: ConstraintFactory.InnerException=>Has.InnerException
Gen: ConstraintExpression.InnerException=>Property("InnerException")
%
/// <summary>
/// Returns a new AttributeConstraint checking for the
/// presence of a particular attribute on an object.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Attribute(Type expectedType)=>new ConstraintExpression().Attribute(expectedType)
Gen: Has.Attribute<T>()=>Attribute(typeof(T))
Gen: ConstraintFactory.Attribute(Type expectedType)=>Has.Attribute(expectedType)
Gen: ConstraintFactory.Attribute<T>()=>Attribute(typeof(T))
Gen: ConstraintExpression.Attribute(Type expectedType)=>this.Append(new AttributeOperator(expectedType))
Gen: ConstraintExpression.Attribute<T>()=>Attribute(typeof(T))
%
/// <summary>
/// With is currently a NOP - reserved for future use.
/// </summary>
Type: ConstraintExpression
Gen: ConstraintExpression.With=>this.Append(new WithOperator())
%
/// <summary>
/// Returns the constraint provided as an argument - used to allow custom
/// custom constraints to easily participate in the syntax.
/// </summary>
Type: Constraint
Cond: !NUNITLITE
Gen: ConstraintExpression.Matches(Constraint constraint)=>this.Append(constraint)
Gen: ConstraintExpression.Matches<T>(Predicate<T> predicate)=>this.Append(new PredicateConstraint<T>(predicate))
%
#
# Constraints Without Arguments
#
/// <summary>
/// Returns a constraint that tests for null
/// </summary>
Gen3: Is.Null=>new NullConstraint()
%
/// <summary>
/// Returns a constraint that tests for True
/// </summary>
Gen3: Is.True=>new TrueConstraint()
%
/// <summary>
/// Returns a constraint that tests for False
/// </summary>
Gen3: Is.False=>new FalseConstraint()
%
/// <summary>
/// Returns a constraint that tests for NaN
/// </summary>
Gen3: Is.NaN=>new NaNConstraint()
%
/// <summary>
/// Returns a constraint that tests for empty
/// </summary>
Gen3: Is.Empty=>new EmptyConstraint()
%
/// <summary>
/// Returns a constraint that tests whether a collection 
/// contains all unique items.
/// </summary>
Gen3: Is.Unique=>new UniqueItemsConstraint()
%
/// <summary>
/// Returns a constraint that tests whether an object graph is serializable in binary format.
/// </summary>
Cond: !NETCF
Gen3: Is.BinarySerializable=>new BinarySerializableConstraint()
%
/// <summary>
/// Returns a constraint that tests whether an object graph is serializable in xml format.
/// </summary>
Cond: !NETCF_1_0
Gen3: Is.XmlSerializable=>new XmlSerializableConstraint()
%
#
# Constraints Taking an Expected Value 
#
/// <summary>
/// Returns a constraint that tests two items for equality
/// </summary>
Gen3: Is.EqualTo(object expected)=>new EqualConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests that two references are the same object
/// </summary>
Gen3: Is.SameAs(object expected)=>new SameAsConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is greater than the suppled argument
/// </summary>
Gen3: Is.GreaterThan(object expected)=>new GreaterThanConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is greater than or equal to the suppled argument
/// </summary>
Gen3: Is.GreaterThanOrEqualTo(object expected)=>new GreaterThanOrEqualConstraint(expected)
Gen3: Is.AtLeast(object expected)=>new GreaterThanOrEqualConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is less than the suppled argument
/// </summary>
Gen3: Is.LessThan(object expected)=>new LessThanConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is less than or equal to the suppled argument
/// </summary>
Gen3: Is.LessThanOrEqualTo(object expected)=>new LessThanOrEqualConstraint(expected)
Gen3: Is.AtMost(object expected)=>new LessThanOrEqualConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the actual
/// value is of the exact type supplied as an argument.
/// </summary>
Gen3: Is.TypeOf(Type expectedType)=>new ExactTypeConstraint(expectedType)
Gen3: Is.TypeOf<T>()=>new ExactTypeConstraint(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is of the type supplied as an argument or a derived type.
/// </summary>
Gen3: Is.InstanceOf(Type expectedType)=>new InstanceOfTypeConstraint(expectedType)
Gen3: Is.InstanceOf<T>()=>new InstanceOfTypeConstraint(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is assignable from the type supplied as an argument.
/// </summary>
Gen3: Is.AssignableFrom(Type expectedType)=>new AssignableFromConstraint(expectedType)
Gen3: Is.AssignableFrom<T>()=>new AssignableFromConstraint(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is assignable from the type supplied as an argument.
/// </summary>
Gen3: Is.AssignableTo(Type expectedType)=>new AssignableToConstraint(expectedType)
Gen3: Is.AssignableTo<T>()=>new AssignableToConstraint(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is a collection containing the same elements as the 
/// collection supplied as an argument.
/// </summary>
Gen3: Is.EquivalentTo(IEnumerable expected)=>new CollectionEquivalentConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is a subset of the collection supplied as an argument.
/// </summary>
Gen3: Is.SubsetOf(IEnumerable expected)=>new CollectionSubsetConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether a collection is ordered
/// </summary>
Gen3: Is.Ordered=>new CollectionOrderedConstraint()
%
/// <summary>
/// Returns a new CollectionContainsConstraint checking for the
/// presence of a particular object in the collection.
/// </summary>
Gen3: Has.Member(object expected)=>new CollectionContainsConstraint(expected)
Gen: ConstraintFactory.Contains(object expected)=>new CollectionContainsConstraint(expected)
Gen: ConstraintExpression.Contains(object expected)=>(CollectionContainsConstraint)this.Append(new CollectionContainsConstraint(expected))
%
/// <summary>
/// Returns a new ContainsConstraint. This constraint
/// will, in turn, make use of the appropriate second-level
/// constraint, depending on the type of the actual argument. 
/// This overload is only used if the item sought is a string,
/// since any other type implies that we are looking for a 
/// collection member.
/// </summary>
Type: ContainsConstraint
Gen: ConstraintFactory.Contains(string expected)=>new ContainsConstraint(expected)
Gen: ConstraintExpression.Contains(string expected)=>(ContainsConstraint)this.Append(new ContainsConstraint(expected))
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value contains the substring supplied as an argument.
/// </summary>
Type: SubstringConstraint
Gen3: Is.StringContaining(string expected)=>new SubstringConstraint(expected)
Gen: ConstraintFactory.ContainsSubstring(string expected)=>new SubstringConstraint(expected)
Gen: ConstraintExpression.ContainsSubstring(string expected)=>(SubstringConstraint)this.Append(new SubstringConstraint(expected))
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value contains the substring supplied as an argument.
/// </summary>
Type: SubstringConstraint
Gen: ConstraintFactory.DoesNotContain(string expected)=>new ConstraintExpression().Not.ContainsSubstring(expected)
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value starts with the substring supplied as an argument.
/// </summary>
Gen: ConstraintFactory.StartsWith(string expected)=>new StartsWithConstraint(expected)
Gen: ConstraintExpression.StartsWith(string expected)=>(StartsWithConstraint)this.Append(new StartsWithConstraint(expected))
Gen3: Is.StringStarting(string expected)=>new StartsWithConstraint(expected)
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value starts with the substring supplied as an argument.
/// </summary>
Type: StartsWithConstraint
Gen: ConstraintFactory.DoesNotStartWith(string expected)=>new ConstraintExpression().Not.StartsWith(expected)
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value ends with the substring supplied as an argument.
/// </summary>
Gen: ConstraintFactory.EndsWith(string expected)=>new EndsWithConstraint(expected)
Gen: ConstraintExpression.EndsWith(string expected)=>(EndsWithConstraint)this.Append(new EndsWithConstraint(expected))
Gen3: Is.StringEnding(string expected)=>new EndsWithConstraint(expected)
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value ends with the substring supplied as an argument.
/// </summary>
Type: EndsWithConstraint
Gen: ConstraintFactory.DoesNotEndWith(string expected)=>new ConstraintExpression().Not.EndsWith(expected)
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value matches the regular expression supplied as an argument.
/// </summary>
Cond: !NETCF
Gen: ConstraintFactory.Matches(string pattern)=>new RegexConstraint(pattern)
Gen: ConstraintExpression.Matches(string pattern)=>(RegexConstraint)this.Append(new RegexConstraint(pattern))
Gen3: Is.StringMatching(string pattern)=>new RegexConstraint(pattern)
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value matches the pattern supplied as an argument.
/// </summary>
Type: RegexConstraint
Cond: !NETCF
Gen: ConstraintFactory.DoesNotMatch(string pattern)=>new ConstraintExpression().Not.Matches(pattern)
%
/// <summary>
/// Returns a constraint that tests whether the path provided 
/// is the same as an expected path after canonicalization.
/// </summary>
Gen3: Is.SamePath(string expected)=>new SamePathConstraint(expected)
%
/// <summary>
/// Returns a constraint that tests whether the path provided 
/// is the same path or under an expected path after canonicalization.
/// </summary>
Gen3: Is.SamePathOrUnder(string expected)=>new SamePathOrUnderConstraint(expected)
%
#
# Constraints with Two Arguments
#
/// <summary>
/// Returns a constraint that tests whether the actual value falls 
/// within a specified range.
/// </summary>
Gen3: Is.InRange(IComparable from, IComparable to)=>new RangeConstraint(from, to)
%
/// <summary>
/// Returns a constraint that tests whether the actual value falls 
/// within a specified range.
/// </summary>
#Gen3: Is.InRange<T>(T from, T to) where T : IComparable=>new RangeConstraint<T>(from, to)
%
